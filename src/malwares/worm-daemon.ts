import {WormAdapter} from '/malwares/worm-adapters';
import {WORM_CONFIG} from '/malwares/worm-config';
//import {LogNsAdapter} from '/resources/helpers';

export async function main(ns) {
    const nsA = new WormAdapter(ns);
    //const logA = new LogNsAdapter(ns);
    const hostConst = JSON.parse(ns.read(WORM_CONFIG.INSTALL_PACKAGE[2]));

    //noinspection InfiniteLoopJS
    while (true) {
        const hostState = {
            minSec: hostConst.minSec,
            actualSec: nsA.getServerSecurityLevel(hostConst.hostname),
            maxMoney: hostConst.maxMoney,
            availMoney: nsA.getServerMoneyAvailable(hostConst.hostname),
        };
        
        if (hostState.actualSec > hostState.minSec) {
            const threadQty = Math.floor(hostConst.freeRam / hostConst.weakenRam);
            //logA.debug(`Weaken estimate time: ${nsA.getWeakenTime(hostConst.hostname)}`);
            nsA.exec(WORM_CONFIG.RUN_PACKAGE[2], hostConst.hostname, threadQty);
            await nsA.sleep(nsA.getWeakenTime(hostConst.hostname) + 100);
            
        } else if (hostState.availMoney < hostState.maxMoney) {
            const threadQty = Math.floor(hostConst.freeRam / hostConst.growRam);
            //logA.debug(`Grow estimate time: ${nsA.getGrowTime(hostConst.hostname)}`);
            nsA.exec(WORM_CONFIG.RUN_PACKAGE[3], hostConst.hostname, threadQty);
            await nsA.sleep(nsA.getGrowTime(hostConst.hostname) + 100);
            
        } else {
            const threadQty = Math.floor(hostConst.freeRam / hostConst.hackRam);
            //logA.debug(`Hack estimate time: ${nsA.getHackTime(hostConst.hostname)}`);
            nsA.exec(WORM_CONFIG.RUN_PACKAGE[1], hostConst.hostname, threadQty);
            await nsA.sleep(nsA.getHackTime(hostConst.hostname) + 100);
        }
    }
}