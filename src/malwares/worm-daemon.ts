export async function main(ns) {
    
    new Worm(ns).activate();
    
}

class Worm {
    private readonly nsA: NsAdapter;
    private readonly malwares: Malwares;
    private readonly hostname: string;
    
    constructor(ns: object) {
        this.nsA = new NsAdapter(ns);
        this.malwares = new Malwares(this.nsA);
        this.hostname = this.nsA.getHostname();
    }
    
    activate(): void {
        while (true) {
            let hostState: HostState = this.retrieveHostState();
            let nextStep: HackingStep = this.identifyWormNextStep(this.hostname, hostState);
            this.executeNextStep(nextStep);
        }
    }
    
    retrieveHostState(): HostState {
        return {
            minSec: this.nsA.getServerMinSecurityLevel(this.hostname),
            actualSec: this.nsA.getServerSecurityLevel(this.hostname),
            maxMoney: this.nsA.getServerMaxMoney(this.hostname),
            availMoney: this.nsA.getServerMoneyAvailable(this.hostname),
        };
    }
    
    private identifyWormNextStep(hostname: string, hostState: HostState): HackingStep {
        
        let nextStep = <HackingStep>{};
        const freeRam = this.nsA.getServerFreeRam(hostname);
        
        if (hostState.actualSec > hostState.minSec) {
            nextStep.malware = 'weaken';
            const scriptRam: number = this.malwares[nextStep.malware].getRamRequirement(hostname);
            nextStep.threadQty = Math.floor(freeRam / scriptRam);
            
        } else if (hostState.availMoney < hostState.maxMoney) {
            nextStep.malware = 'grow';
            const scriptRam: number = this.malwares[nextStep.malware].getRamRequirement(hostname);
            nextStep.threadQty = Math.floor(freeRam / scriptRam);
            
        } else {
            nextStep.malware = 'hack';
            const scriptRam: number = this.malwares[nextStep.malware].getRamRequirement(hostname);
            nextStep.threadQty = Math.floor(freeRam / scriptRam);
        }
        
    return nextStep;
    }
    
    private executeNextStep(nextStep: HackingStep): void {
        this.malwares[nextStep.malware].execute(this.hostname, this.hostname, nextStep.threadQty);
    }
}

type HostState = {
    minSec: number,
    actualSec: number,
    maxMoney: number,
    availMoney: number,
}

type HackingStep = {
    malware: string,
    threadQty: number,
}

class Malwares {
    hack: Hack;
    hackFilePath: string;
    weaken: Weaken;
    weakenFilePath: string;
    grow: Grow;
    growFilePath: string;
    
    constructor(nsA: NsAdapter) {
        this.hackFilePath = '/malwares/hack.js';
        this.hack = new Hack(nsA, this.hackFilePath);
        this.weakenFilePath = '/malwares/weaken.js';
        this.weaken = new Weaken(nsA, this.weakenFilePath);
        this.growFilePath = '/malwares/grow.js';
        this.grow = new Grow(nsA, this.growFilePath);
    }
    
}

class Malware {
    nsA: NsAdapter;
    filePath: string;
    
    constructor(nsA: NsAdapter, filePath: string) {
        this.nsA = nsA;
        this.filePath = filePath;
    }
    
    getRamRequirement(runnerName: string): number {
        return this.nsA.getScriptRam(this.filePath, runnerName);
    }
    
    execute(runnerName: string, targetName: string, threadsQty: number, marketImpact: boolean = false,
        blockId: number = 0, stepId: number = 0): void {
        this.nsA.exec(this.filePath, runnerName, threadsQty, targetName, marketImpact, blockId, stepId);
    }
    
}

class Weaken extends Malware {
    
    constructor(nsA: NsAdapter, filePath: string) {
        super(nsA, filePath);
    }
    
    getDuration(targetName: string): number {
        return this.nsA.getWeakenTime(targetName);
    }
    
    threadsQtyToDecreaseSecurityOf(runnerName: string, securityQtyToDecrease: number): number {
        //const coresQty: number = this.nsA.getServer(runnerName).cpuCores;
        const coresQty: number = 1;
        const unitSecurityDecrease: number = this.nsA.weakenAnalyze(1, coresQty);
        return Math.ceil(securityQtyToDecrease / unitSecurityDecrease);
    }
    
}

class Grow extends Malware {
    
    constructor(nsA: NsAdapter, filePath: string) {
        super(nsA, filePath);
    }
    
    getDuration(targetName: string): number {
        return this.nsA.getGrowTime(targetName);
    }
    
    getUnitSecurityIncrease(): number {
        return this.nsA.growthAnalyzeSecurity(1);
    }
    
    getUnitMoneyIncrease(targetName: string): number {
        if (this.nsA.fileExists('Formulas.exe', 'home') === true) {
            const target: object = this.nsA.getServer(targetName);
            //const coresQty: number = this.nsA.getServer(runnerName).cpuCores;
            const coresQty: number = 1;
            this.nsA.getGrowPercent(target, coresQty);
            
        } else {
            return undefined;
        }
    }
    
    getThreadsQtyToIncreaseMoneyOf(targetName: string, moneyRatioToIncrease: number): number {
        //const coresQty: number = this.nsA.getServer(runnerName).cpuCores;
        const coresQty: number = 1;
        return Math.ceil(this.nsA.growthAnalyze(targetName, 1 + moneyRatioToIncrease, coresQty));
    }
}

class Hack extends Malware {
    
    constructor(nsA: NsAdapter, filePath: string) {
        super(nsA, filePath);
    }
    
    getDuration(targetName: string): number {
        return this.nsA.getHackTime(targetName);
    }
    
    getUnitMoneyDecrease(targetName: string): number {
        return this.nsA.hackAnalyze(targetName);
    }
    
    getUnitSecurityIncrease(): number {
        return this.nsA.hackAnalyzeSecurity(1);
    }
    
    getSuccessRate(targetName: string): number {
        return this.nsA.hackAnalyzeChance(targetName);
    }
    
    getThreadsQtyToDecreaseMoneyOf(targetName: string, moneyRatioToDecrease: number): number {
        const moneyQtyToDecrease = moneyRatioToDecrease * this.nsA.getServerMoneyAvailable(targetName);
        return Math.ceil(this.nsA.hackAnalyzeThreads(targetName, moneyQtyToDecrease));
    }
}

class NsAdapter {
    private readonly ns;
    formulas: any;
    
    constructor(ns: object) {
        this.ns = ns;
    }
    
    getScriptRam(filePath: string, runnerName: string): number {
        return this.ns.getScriptRam(filePath, runnerName);
        
    }
    
    exec(filePath: string, runnerName: string, threadsQty: number, targetName: string, marketImpact: boolean,
        blockId: number, stepId: number) {
        this.ns.exec(filePath, runnerName, threadsQty, targetName, threadsQty, marketImpact, blockId, stepId);
    }
    
    getWeakenTime(targetName: string): number {
        return this.ns.getWeakenTime(targetName);
    }
    
    weakenAnalyze(threadQty: number, coresQty: number): number {
        return this.ns.weakenAnalyze(threadQty, coresQty);
    }
    
    getGrowTime(targetName: string): number {
        return this.ns.getGrowTime(targetName);
    }
    
    growthAnalyzeSecurity(threadQty: number): number {
        return this.ns.growthAnalyzeSecurity(threadQty);
    }
    
    fileExists(fileName: string, hostname: string): boolean {
        return this.ns.fileExists(fileName, hostname);
    }
    
    getServer(targetName: string): object {
        return this.ns.getServer(targetName);
    }
    
    getPlayer(): object {
        return this.ns.getPlayer();
    }
    
    getGrowPercent(target: object, coresQty: number): number {
        return this.ns.formulas.hacking.growPercent(target, 1, this.getPlayer(), coresQty);
    }
    
    growthAnalyze(targetName: string, threadCount: number, coresQty: number): number {
        return this.ns.growthAnalyze(targetName, threadCount, coresQty);
    }
    
    getHackTime(targetName: string): number {
        return this.ns.getHackTime(targetName);
    }
    
    hackAnalyze(targetName: string): number {
        return this.ns.hackAnalyze(targetName);
    }
    
    hackAnalyzeSecurity(number: number): number {
        return this.ns.hackAnalyzeSecurity(number);
    }
    
    hackAnalyzeChance(targetName: string): number {
        return this.ns.hackAnalyzeChance(targetName);
    }
    
    getServerMoneyAvailable(targetName: string): number {
        return this.ns.getServerMoneyAvailable(targetName);
    }
    
    hackAnalyzeThreads(targetName: string, moneyQtyToDecrease: number): number {
        return this.ns.hackAnalyzeThreads(targetName, moneyQtyToDecrease);
    }
    
    getHostname(): string {
        return this.ns.getHostname();
    }
    
    getServerMinSecurityLevel(hostname: string): number {
        return this.ns.getServerMinSecurityLevel(hostname);
    }
    
    getServerSecurityLevel(hostname: string): number {
        return this.ns.getServerSecurityLevel(hostname);
    }
    
    getServerMaxMoney(hostname: string): number {
        return this.ns.getServerMaxMoney(hostname);
    }
    
    getServerFreeRam(hostname: string): number {
        return this.ns.getServerMaxRam(hostname) - this.ns.getServerUsedRam(hostname);
    }
}