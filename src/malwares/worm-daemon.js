var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
export function main(ns) {
    return __awaiter(this, void 0, void 0, function* () {
        new Worm(ns).activate();
    });
}
class Worm {
    constructor(ns) {
        this.nsA = new NsAdapter(ns);
        this.malwares = new Malwares(this.nsA);
        this.hostname = this.nsA.getHostname();
    }
    activate() {
        while (true) {
            let hostState = this.retrieveHostState();
            let nextStep = this.identifyWormNextStep(this.hostname, hostState);
            this.executeNextStep(nextStep);
        }
    }
    retrieveHostState() {
        return {
            minSec: this.nsA.getServerMinSecurityLevel(this.hostname),
            actualSec: this.nsA.getServerSecurityLevel(this.hostname),
            maxMoney: this.nsA.getServerMaxMoney(this.hostname),
            availMoney: this.nsA.getServerMoneyAvailable(this.hostname),
        };
    }
    identifyWormNextStep(hostname, hostState) {
        let nextStep = {};
        const freeRam = this.nsA.getServerFreeRam(hostname);
        if (hostState.actualSec > hostState.minSec) {
            nextStep.malware = 'weaken';
            const scriptRam = this.malwares[nextStep.malware].getRamRequirement(hostname);
            nextStep.threadQty = Math.floor(freeRam / scriptRam);
        }
        else if (hostState.availMoney < hostState.maxMoney) {
            nextStep.malware = 'grow';
            const scriptRam = this.malwares[nextStep.malware].getRamRequirement(hostname);
            nextStep.threadQty = Math.floor(freeRam / scriptRam);
        }
        else {
            nextStep.malware = 'hack';
            const scriptRam = this.malwares[nextStep.malware].getRamRequirement(hostname);
            nextStep.threadQty = Math.floor(freeRam / scriptRam);
        }
        return nextStep;
    }
    executeNextStep(nextStep) {
        this.malwares[nextStep.malware].execute(this.hostname, this.hostname, nextStep.threadQty);
    }
}
class Malwares {
    constructor(nsA) {
        this.hackFilePath = '/malwares/hack.js';
        this.hack = new Hack(nsA, this.hackFilePath);
        this.weakenFilePath = '/malwares/weaken.js';
        this.weaken = new Weaken(nsA, this.weakenFilePath);
        this.growFilePath = '/malwares/grow.js';
        this.grow = new Grow(nsA, this.growFilePath);
    }
}
class Malware {
    constructor(nsA, filePath) {
        this.nsA = nsA;
        this.filePath = filePath;
    }
    getRamRequirement(runnerName) {
        return this.nsA.getScriptRam(this.filePath, runnerName);
    }
    execute(runnerName, targetName, threadsQty, marketImpact = false, blockId = 0, stepId = 0) {
        this.nsA.exec(this.filePath, runnerName, threadsQty, targetName, marketImpact, blockId, stepId);
    }
}
class Weaken extends Malware {
    constructor(nsA, filePath) {
        super(nsA, filePath);
    }
    getDuration(targetName) {
        return this.nsA.getWeakenTime(targetName);
    }
    threadsQtyToDecreaseSecurityOf(runnerName, securityQtyToDecrease) {
        //const coresQty: number = this.nsA.getServer(runnerName).cpuCores;
        const coresQty = 1;
        const unitSecurityDecrease = this.nsA.weakenAnalyze(1, coresQty);
        return Math.ceil(securityQtyToDecrease / unitSecurityDecrease);
    }
}
class Grow extends Malware {
    constructor(nsA, filePath) {
        super(nsA, filePath);
    }
    getDuration(targetName) {
        return this.nsA.getGrowTime(targetName);
    }
    getUnitSecurityIncrease() {
        return this.nsA.growthAnalyzeSecurity(1);
    }
    getUnitMoneyIncrease(targetName) {
        if (this.nsA.fileExists('Formulas.exe', 'home') === true) {
            const target = this.nsA.getServer(targetName);
            //const coresQty: number = this.nsA.getServer(runnerName).cpuCores;
            const coresQty = 1;
            this.nsA.getGrowPercent(target, coresQty);
        }
        else {
            return undefined;
        }
    }
    getThreadsQtyToIncreaseMoneyOf(targetName, moneyRatioToIncrease) {
        //const coresQty: number = this.nsA.getServer(runnerName).cpuCores;
        const coresQty = 1;
        return Math.ceil(this.nsA.growthAnalyze(targetName, 1 + moneyRatioToIncrease, coresQty));
    }
}
class Hack extends Malware {
    constructor(nsA, filePath) {
        super(nsA, filePath);
    }
    getDuration(targetName) {
        return this.nsA.getHackTime(targetName);
    }
    getUnitMoneyDecrease(targetName) {
        return this.nsA.hackAnalyze(targetName);
    }
    getUnitSecurityIncrease() {
        return this.nsA.hackAnalyzeSecurity(1);
    }
    getSuccessRate(targetName) {
        return this.nsA.hackAnalyzeChance(targetName);
    }
    getThreadsQtyToDecreaseMoneyOf(targetName, moneyRatioToDecrease) {
        const moneyQtyToDecrease = moneyRatioToDecrease * this.nsA.getServerMoneyAvailable(targetName);
        return Math.ceil(this.nsA.hackAnalyzeThreads(targetName, moneyQtyToDecrease));
    }
}
class NsAdapter {
    constructor(ns) {
        this.ns = ns;
    }
    getScriptRam(filePath, runnerName) {
        return this.ns.getScriptRam(filePath, runnerName);
    }
    exec(filePath, runnerName, threadsQty, targetName, marketImpact, blockId, stepId) {
        this.ns.exec(filePath, runnerName, threadsQty, targetName, threadsQty, marketImpact, blockId, stepId);
    }
    getWeakenTime(targetName) {
        return this.ns.getWeakenTime(targetName);
    }
    weakenAnalyze(threadQty, coresQty) {
        return this.ns.weakenAnalyze(threadQty, coresQty);
    }
    getGrowTime(targetName) {
        return this.ns.getGrowTime(targetName);
    }
    growthAnalyzeSecurity(threadQty) {
        return this.ns.growthAnalyzeSecurity(threadQty);
    }
    fileExists(fileName, hostname) {
        return this.ns.fileExists(fileName, hostname);
    }
    getServer(targetName) {
        return this.ns.getServer(targetName);
    }
    getPlayer() {
        return this.ns.getPlayer();
    }
    getGrowPercent(target, coresQty) {
        return this.ns.formulas.hacking.growPercent(target, 1, this.getPlayer(), coresQty);
    }
    growthAnalyze(targetName, threadCount, coresQty) {
        return this.ns.growthAnalyze(targetName, threadCount, coresQty);
    }
    getHackTime(targetName) {
        return this.ns.getHackTime(targetName);
    }
    hackAnalyze(targetName) {
        return this.ns.hackAnalyze(targetName);
    }
    hackAnalyzeSecurity(number) {
        return this.ns.hackAnalyzeSecurity(number);
    }
    hackAnalyzeChance(targetName) {
        return this.ns.hackAnalyzeChance(targetName);
    }
    getServerMoneyAvailable(targetName) {
        return this.ns.getServerMoneyAvailable(targetName);
    }
    hackAnalyzeThreads(targetName, moneyQtyToDecrease) {
        return this.ns.hackAnalyzeThreads(targetName, moneyQtyToDecrease);
    }
    getHostname() {
        return this.ns.getHostname();
    }
    getServerMinSecurityLevel(hostname) {
        return this.ns.getServerMinSecurityLevel(hostname);
    }
    getServerSecurityLevel(hostname) {
        return this.ns.getServerSecurityLevel(hostname);
    }
    getServerMaxMoney(hostname) {
        return this.ns.getServerMaxMoney(hostname);
    }
    getServerFreeRam(hostname) {
        return this.ns.getServerMaxRam(hostname) - this.ns.getServerUsedRam(hostname);
    }
}
//# sourceMappingURL=worm-daemon.js.map