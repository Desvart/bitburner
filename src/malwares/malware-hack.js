var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Log } from '/resources/helpers';
import { getService } from '/resources/service';
export function main(ns) {
    return __awaiter(this, void 0, void 0, function* () {
        const log = new Log(ns);
        const malware = 'HACK';
        // noinspection DuplicatedCode
        let timestampStart = Date.now();
        const target = ns.args[0];
        const threadCount = ns.args[1];
        let delay = ns.args[2]; //ms
        delay !== null && delay !== void 0 ? delay : (delay = 0);
        const blockId = ns.args[3];
        const stepId = ns.args[4];
        const marketImpact = ns.args[5];
        let caller = ns.args[6];
        if (typeof caller !== undefined)
            caller = caller + ' > ';
        else
            caller !== null && caller !== void 0 ? caller : (caller = '');
        let operationId = '';
        if (blockId !== 0)
            operationId = `- ${blockId}-${stepId} `;
        log.info(`${caller}${malware} ${target} (${threadCount}x) ${operationId}- START in ${log.formatDuration(delay)}`);
        yield ns.sleep(delay);
        timestampStart = Date.now();
        log.info(`${caller}${malware} ${target} (${threadCount}x) ${operationId}- START now`);
        const earnedMoney = log.formatMoney(yield hack(ns, target, threadCount, marketImpact));
        const timestampStop = Date.now();
        const hackDuration = log.formatDuration(timestampStop - timestampStart);
        log.success(`${caller}${malware} ${target} (${threadCount}x) ${operationId}- STOP: ${hackDuration} duration; Gain: +${earnedMoney}`);
        const node = yield getService(ns, 10).then(network => network.getNode(target));
        const msg = `Money ${log.formatMoney(node.getAvailableMoney())} / ${log.formatMoney(node.maxMoney)}, SEC ${node.getSecurityLevel()} / ${node.minSec}`;
        log.info(`STATUS ${target}: ${msg}`);
    });
}
function hack(ns, target, threads = 1, stock = false) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield ns.hack(target, { threads: threads, stock: stock });
    });
}
//# sourceMappingURL=malware-hack.js.map